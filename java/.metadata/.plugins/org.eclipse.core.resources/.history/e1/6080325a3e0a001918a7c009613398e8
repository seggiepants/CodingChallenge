package com.segludian.digitaltennis;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.event.ComponentEvent;
import java.awt.event.ComponentListener;
import java.awt.image.BufferStrategy;

import javax.swing.JOptionPane;
import javax.swing.JPanel;

public class GameWorld extends JPanel implements ComponentListener {
	
	/**
	 * Make eclipse happy add a version UID. 
	 */
	private static final long serialVersionUID = 1L;
	
	private final int STATE_SERVE = 0;
	private final int STATE_PLAY = 1;
	private final int STATE_PAUSE = 2;
	private final int STATE_GAME_OVER = 3;
	
	private final int TARGET_SCORE = 5;
	private final double MESSAGE_SPEED = 75.0; // Speed of message in pixels per second.
	
	private BufferStrategy strategy;
	
	private Ball ball;
	private Player playerLeft;
	private Player playerRight;
	private final int fontDistance = 32;
	private final int wallDistance = 32;
	private final int wallSize = 8;
	private Rectangle topWall;
	private Rectangle bottomWall;
	private Rectangle leftOutZone;
	private Rectangle rightOutZone;
	private Color wallColor;
	private Font font;
	private int state = STATE_SERVE;
	private int messageY = 0;
	private String message = "";
	Main parent;
	private boolean running = false;
	
	GameWorld(Main parent, Controller left, Controller right) {
		this.parent = parent;
		this.addComponentListener(this);

		//parent.createBufferStrategy(2);
		//strategy = parent.getBufferStrategy();
		
		wallColor = Color.WHITE;
		playerLeft = new Player(left);
		playerRight = new Player(right);
		ball = new Ball(this.getWidth() / 2, this.getHeight() / 2);
		resizeWorld();
		font = new Font("SansSerif", Font.BOLD, 21);
		newGame();
		runGameLoop();
		this.setVisible(true);
	}
	
	public void newGame() {		
		playerLeft.newGame(this.getLeftPlayerX(), this.getPlayerY());
		playerRight.newGame(this.getRightPlayerX(), this.getPlayerY());
		stateServe();
	}
	
	public void stateGameOver() {
		// Don't switch states unless someone won.
		if (playerLeft.getScore() == this.TARGET_SCORE || playerRight.getScore() == this.TARGET_SCORE) {
			state = STATE_GAME_OVER;
			if (playerLeft.isHuman() && playerRight.isHuman())
			{
				if (playerLeft.getScore() == this.TARGET_SCORE) {
					message = "Player 1 Wins!";
				}
				else {
					message = "Player 2 Wins!";
				}
			}
			else {
				if (playerLeft.getScore() == this.TARGET_SCORE) {
					message = "You Win!";
				}
				else {
					message = "Sorry, you lost.";
				}
			}
			this.messageY = 0;
		}
		
	}
	
	public void statePause() {
		if (state == STATE_PAUSE) {
			state = STATE_PLAY;
		}
		else {
			state = STATE_PAUSE;
			messageY = this.getHeight() / 2;
			message = "Paused - Press \"P\" to resume";
		}
	}
	
	public void statePlay() {
		double newAngle;
		int quadrant;

		state = STATE_PLAY;
		// Want a random angle between -30 and + 30 degrees or 150 to 210 degrees, but not exactly 0, or 180 degrees.
		// I will make 4 areas 1-30, 330-359, 150-179, and 180-210
		newAngle = (Math.random() * Math.PI / 6) + .001;
		quadrant = (int)(Math.random() * 4);
		switch(quadrant)
		{
		case 1:
			newAngle = Math.PI - newAngle;
			break;
		case 2:
			newAngle = Math.PI + newAngle;
			break;
		case 3:
			newAngle = (2.0) * Math.PI - newAngle;
			break;
		}
		ball.setAngle(newAngle);
		ball.setSpeed(ball.getDefaultSpeed());
	}
	
	public void stateServe() {
		int width = this.getWidth();		
		state = STATE_SERVE;
		ball.setX((double) width / 2);
		ball.setY(0);
		ball.setAngle((3.0 * Math.PI) / 2.0);  // Down.
		ball.setSpeed(ball.getDefaultSpeed()); // Fall down.
	}

	
	// Update and Draw commands.
	/**
	 * Draw the game world.
	 * @param g: Graphics rendering context.
	 */
	public void draw(Graphics g) {
		
		int width = this.getWidth();
		int height = this.getHeight();
		int centerX = width / 2;		
		String temp;
		
		// Clear the window
		g.setColor(Color.BLACK);;
		g.clearRect(0,  0,  width,  height);
				
		
		// Draw the borders.
		g.setColor(wallColor);;
		g.fillRect(topWall.x,  topWall.y,  topWall.width,  topWall.height);
		g.fillRect(bottomWall.x,  bottomWall.height,  bottomWall.width,  bottomWall.height);
		
		// Draw a dashed line down the center. 
		g.setColor(Color.WHITE);
		for(int y = 0; y < height; y+= 16) {
			g.drawLine(centerX, y, centerX, y + 8);
		}
		
		// Draw the score.
		// Left Player
		g.setColor(Color.WHITE);
		g.setFont(font);
		g.drawString(String.format("%02d",  playerLeft.getScore()), fontDistance, fontDistance);
		
		// Right Player.
		temp = String.format("%02d",  playerRight.getScore());
		g.drawString(temp,  fontDistance,  width - g.getFontMetrics().stringWidth(temp) - fontDistance);
		
		// Draw the active objects
		playerLeft.draw(g);
		playerRight.draw(g);
		ball.draw(g);
		
		if ((this.state == STATE_GAME_OVER) || (this.state == STATE_PAUSE)) {
			int messageX = (width - g.getFontMetrics().stringWidth(message)) / 2;
			g.drawString(this.message, messageX, this.messageY);
		}
	}
	
	/**
	 * Update the game world.
	 * @param dt: Milliseconds elapsed since the previous frame.
	 */
	public void update(double dt) {
		
		Rectangle ballRect;

		if (state == STATE_PAUSE) {
			// Do Nothing
		}
		else if (state == STATE_PLAY) {
			// Update the game objects.
			playerLeft.update(dt);
			playerRight.update(dt);
			ball.update(dt);
			
			ballRect = ball.getRectangle();
			
			if (ballRect.intersects(leftOutZone)) {
				playerRight.addPoint();
			}
			
			if (ballRect.intersects(rightOutZone)) {
				playerLeft.addPoint();
			}
			// ZZZ MORE PLEASE
		}
		else if (state == STATE_SERVE) {
			// Move the ball down to the center then switch to play mode.
			double targetY = this.getHeight() / 2;
			if (ball.getY() >= targetY) {
				ball.setY(targetY);
				statePlay();
			}
			else {
				ball.update(dt);
			}
		}
		else if (state == STATE_GAME_OVER) {
			int targetY = (this.getHeight() / 2);
			if (messageY >= targetY) {
				messageY = targetY;
				if (JOptionPane.showConfirmDialog(parent, "Game Over!\r\nWould you like to play again?", "Game Over", JOptionPane.YES_NO_OPTION , JOptionPane.QUESTION_MESSAGE) == JOptionPane.YES_OPTION) {
					// Start a new game.
					newGame();
				}
				else {
					// Return to the main menu.
					parent.menuEvent("mainMenu");
				}
			}
			else {
				messageY += Math.max(1, (int)((dt * MESSAGE_SPEED) / 1000.0));
			}
		}
		
	}
	
	private double getLeftPlayerX()
	{
		return wallDistance; 
	}
	
	private double getRightPlayerX() {
		return (double) this.getWidth() - wallDistance - Player.getWidth();
	}
	
	private double getPlayerY() {
		return (double) (this.getHeight() - Player.getHeight()) / 2.0; 
	}
	
	public void resizeWorld() {
		int width = this.getWidth();
		int height = this.getHeight();
		
		playerLeft.clipXY((double) wallDistance, height);
		playerRight.clipXY((double) width - wallDistance - Player.getWidth(), height);
		ball.setX((double) width / 2);
		ball.setY((double) height / 2);
		
		this.topWall = new Rectangle(this.wallSize, 0, width - (2 * this.wallSize) , this.wallSize);
		this.bottomWall =  new Rectangle(this.wallSize, height - this.wallSize, width - (2 * this.wallSize), this.wallSize);
		this.leftOutZone = new Rectangle(0, 0, this.wallSize, height);
		this.rightOutZone = new Rectangle(width - this.wallSize, 0, this.wallSize, height);
		
	}
	
	public void componentResized(ComponentEvent e) {
		resizeWorld();
    }
	
	public void componentHidden(ComponentEvent e) {
		// Do nothing, only wanted resize
		// Well maybe auto-pause
    }

    public void componentMoved(ComponentEvent e) {
    	// Do nothing, only wanted resize
    }

    public void componentShown(ComponentEvent e) {
    	// Do nothing, only wanted resize
    }

    @Override
    public void paintComponent(Graphics g) {
    	//Graphics2D g2d = (Graphics2D) strategy.getDrawGraphics();
    	draw(g);
    	g.dispose();
    	//strategy.show();
    	/*
    	System.out.print(this.getWidth());    	
    	System.out.print("x");
    	System.out.println(this.getHeight());
    	System.out.println(this.isVisible());
    	*/
    	
    }
    
    @Override
    public Dimension getPreferredSize() {
        return new Dimension(640, 480);
    }
    
    
    // Starts a new thread and runs the game loop in it.
    public void runGameLoop()
    {
       Thread loop = new Thread()
       {
          public void run()
          {
             gameLoop();
          }
       };
       this.running = true;
       loop.start();
    }
    
    // Only run this in another Thread!
    private void gameLoop()
    {       
       
       //If we are able to get as high as this FPS, don't render again.
       final double TARGET_FPS = 60;
       final double TARGET_TIME = 1000000000 / TARGET_FPS;
       
       //Store the last time we ran the draw and update loops.
       double currentTime = System.nanoTime() - TARGET_TIME; // Want the first loop to not be zero.
       double previousTime;
       double dt;
       
       while (this.running)
       {
    	  previousTime = currentTime;
          currentTime = System.nanoTime();
          // Compute delta time in milliseconds not nanoseconds.
          // Go no faster than target time
          dt = (Math.max(TARGET_TIME, currentTime - previousTime)) / 1000.0;
          
          this.update(dt);
          this.repaint();
          
          // Yield until it has been at least the target time. This saves the CPU from hogging.          
          while ( currentTime - previousTime < TARGET_TIME) {
        	  Thread.yield();

        	  // This stops the app from consuming all your CPU.
        	  try {Thread.sleep(1);} catch(Exception e) {}
        	  currentTime = System.nanoTime(); 
          }
       }
    }	
}
